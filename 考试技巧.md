0# map
一对一的hash，遇到字符串搭配数组的时候就不需要hash了。
```C++
#include<map>
map<int, string> p;
string s;
int i;
p[i]=s;//insert 
begin()//返回指向map头部的迭代器
clear(）// 删除所有元素
count() //返回指定元素出现的次数
empty()//如果map为空则返回true
end()//返回指向map末尾的迭代器
erase()// 删除一个元素
find()// 查找一个元素
lower_bound()//返回键值>=给定元素的第一个位置
size()//返回map中元素的个数
upper_bound() // 返回键值>给定元素的第一个位置
```
# 快速读写
>如果想尝试一下比较可的优化，大概“寥寥”60几行吧，所以还是老实的用`read()`
```C++
int read()
{
	int x=0,w=1;
	char ch=0;
	while (ch<'0'||ch>'9')    
	{
		if (ch=='-') w=-1;     
		ch=getchar();             
	}
	while (ch>='0'&&ch<='9')   
	{
		x=x*10+(ch-'0');  
		ch=getchar(); 
	}
	return x*w;
}
inline void write(int x)
{
	static int sta[35];
	int top=0;
	do
		sta[top++]=x%10,x/=10;
	while (x);
	while (top) putchar(sta[--top]+48);
}
```

# LCA
链式前向星
```C++
int Head[N],Next[N],adj[N],tot;    //太简单不解释
void add(int i,int j)
{
    tot++;
    Next[tot]=Head[i];
    Head[i]=tot;
    adj[tot]=j;
}
```
第一个dfs用来初始化每一个结点的深度及其父节点
```C++
void dfs(int a)
{
    for(int i=Head[a];i;i=Next[i])        //邻接表的具体用法
    {
        int k=adj[i];
        if(k==p[a][0])
            continue;
        deep[k]=deep[a]+1;            //deep数组存储结点的深度（显而易见）
        p[k][0]=a;                           //p[i][j]表示i的j次方倍祖先
        dfs(k);
    }
}
```
接下来用简单的两层for循环计算出每个结点的j次方倍祖先
```C++
void init()
{
    for(int j=1;(1<<j)<=n;j++)
        for(int i=1;i<=n;i++)
            p[i][j]=p[p[i][j-1]][j-1];
}
```
然后就是LCA的过程了
```C++
int lca(int a,int b)
{
    if(deep[a]>deep[b])               //保持b在a下面
    {
        int t=a;
        a=b;
        b=t;
    }
    int f=deep[b]-deep[a];
    for(int i=0;(1<<i)<=f;i++)       //调整b使a与b深度相同
        if((1<<i)&f)
            b=p[b][i];
    if(a!=b)
    {
        for(int i=100;i>=0;i--)
            if(p[a][i]!=p[b][i])
                a=p[a][i],b=p[b][i];  //每次跳转至它们的i次方倍祖先
        a=p[a][0];                               //a的父亲就是最终答案
    }
    return a;
}
```
第二次dfs进行简单的统计，每个结点累加其所有孩子结点的权值，再取最大值
```C++
void dfs2(int a)
{
    for(int i=Head[a];i;i=Next[i])
    {
        int k=adj[i];
        if(k==p[a][0])
            continue;
        dfs2(k);
        d[a]+=d[k];
    }
    ans=max(ans,d[a]);
}
```
