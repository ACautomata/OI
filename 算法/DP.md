# DP
## 树形DP
给定一颗有N个节点的树（一般是无根树，就有N-1条无向边），可以任选一个节点作为根节点

一般以节点从深到浅（子树从小到大）的顺序作为dp阶段顺序

dp的状态表示中，第一维通常是节点编号（节点编号代表了以该节点为根的子树）

对于每个节点x，先递归在它的每个子节点上进行dp，回溯时，从子节点向x进行状态转移

一般就是`dp[x][i]`，其中`x`表示在`x`子树下的（相关条件），`i`表示选择状态。

树形DP一定伴随着**链式前向星**，


## lower_bound & upper_bound
lower_bound: 在序列a中找到的第一个>=x的数字的地址
upper_bound: 在序列a中找到的第一个>x的数字的地址
```C++
lower_boud(序列，范围，数字);
upper_boud(序列，范围，数字);
```
>有关`*lower_bound`以及`lower_bound(a, a + n, 1) - a`的二三事
因为`lower_bound`本身返回的是一个所找到的值得地址，地址是一个**十六进制**的数字？，也就是说在我们调试的时候所遇到的`0x.....`之云云。

而为了规避这种情况，我们引入了一个`*`，就是输出当前指针（地址）所指向的值，这就是一个十进制的数字（或者你指向的东西吧）
比如现在有`a -> b`，即`a`作为一个指针指向`b`，假定`a = 0x02, b = 1`，想要输出`a`指向的值就只能用`*a`。也就是我们在定义`a`的时候所用到的`int *a`

至于`lower_bound(a, a + n, 1) - a`，返回的就是他所在的位置，`-1`应该是因为`以0开头`吧

## LIS_最长上升子序列
 即在一个数列中，呈上升趋势（从小到大）的部分的非绝对连接的一组序列.{我自己乱写的}
>在计算机科学上是指一个序列中最长的单调递增的子序列。

主要情况的区分就在于**是否可以令数字相等**以及**非降序的子序列**。
我自己的解释里面就明确了子序列以及子串的区别——子序列中的元素在序列当中不一定是连续的，但是子串要求绝对的连续。
比如：`1243567`.`3567`可以被认为是一个上升的子串。但是`123567`不能被认为是一个子串，只能被认为是一个最长上升子序列。
## 求LIS的解法
**甲：DP**
DP的解法是最简单且最占用时间的方法。`O(n*n)`。 
通过对一个序列的一部分的子序列进行最长上升子序列的求解，推出全局的最长上升子序列（DP的操作）。

比如我们需要求出长度为`的`列的LIS，那么就可以先求出`n-1`的长度的序列的LIS，求出`n-1`的LIS，就可以先求出`n-2`的LIS，依次递推。

当然在这个过程中，我们会进行对元素替换的操作。因此这种方法**只能用于LIS长度的求解**。
```C++
f[i] = max(f[j] + 1, f[i]) (1 <= j < i, a[j] < a[i] )
```
边界：`f[i] = 1`
目标：`ans = max(ans, f[i])`
**还有贪心·二分、树状数组的做法。用量不高。**
# 状压DP
先记录一些位运算：（二进制）
```C++
x >> 1 : 去掉最后一位 10010 >> 1 = 1001

x << 1 : 最末尾加上1  10010 << 1 = 100101

x | 1  : 把最后一位变成1 10010 | 1 = 10011

x & -2 : 把最后一位变成0 1001 & -2 = 1000

x ^ 1  : 最后一位取反 1000 ^ 1 = 1001

x & ~ (1 << (k - 1)) : 右数第k位变成0 110 | (1<<2) = (0)10

x & 7 : 取末尾三位 10111 & 7 = 111

x & 1 : 判断奇偶 111 & 1 = 1 (111)2 = (7)10
------------------------------------------------------------------
1<<(k-1)&x 判断第k位值为0的情况。
1<<(k-1)^x 相同得1，不同取0.
1<<(k-1)|x 判断第k位值为1的情况。
f[1][1<<(i-1)] 经常会有的赋初值的情况。
```
> 状压DP，即用二进制存储的形式进行简单的压缩，但部分的状压DP只是采用了状压DP的思想。
```C++
pow(x, n)：x的n次方
```
# 背包
>这里是双肩包算法。
## 01BAG
>有贼，夜寇豪宅，可得者甚多，然不可全负，取何而不枉？

输入

第一行：两个整数，M(背包容量，M≤200)和N(物品数量，N≤30)；

第2..N+1行：每行二个整数Wi，Ci，表示每个物品的重量和价值。

输出

仅一行，一个数，表示最大总价值。

Input

10 4
2 1
3 3
4 5
7 9

Output

12
```C++
#include<iostream>
using namespace std;
int v[1010], w[1010], dp[1010], n, m;
int main()
{
	cin >> m >> n;
	for(int i = 1; i <= n; i++)
		cin >> w[i] >> v[i];
	for(int i = 1; i <= n; i++)
		for(int j = m; j >= w[i]; j--)
			dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
	cout << dp[m] << endl;
	return 0;
}
```
**完全背包**
在01的基础上去除了数量的限制。
```C++
#include<iostream>
using namespace std;
int v[1010], w[1010], dp[1010], n, m;
int main()
{
	cin >> m >> n;
	for(int i = 1; i <= n; i++)
		cin >> w[i] >> v[i];
	for(int i = 1; i <= n; i++)
		for(int j = w[i]; j <= m; j++)
			dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
	cout << dp[m] << endl;
	return 0;
}
```
**多重背包**
在01的基础上添加了每个物品的件数，添加一次`k`的循环即可。
```C++
#include<iostream>
using namespace std;
int v[1010], w[1010], dp[1010], n, m, p[1010];
int main()
{
	cin >> m >> n;
	for(int i = 1; i <= n; i++)
		cin >> w[i] >> v[i] >> p[i];
	for(int i = 1; i <= n; i++)
		for (int k = 1; k <= p[i]; k++)
			for(int j = m; j >= w[i]; j--)
				dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
	cout << dp[m] << endl;
	return 0;
}
```

