>首先，作为一个蒟蒻，要是`DFS`和`BFS`都不会的话，就难以在OI里面存活了。（然后真的不会）
如果:树   ->最短路、最小生成树.....
如果:地图 ->搜索、DP
  又如果:查找路径
    搜索！
# DFS
字如其人，深度优先搜索，不撞墙不回头。

该算法讲解时常常与 BFS 并列，但两者除了都能遍历图的连通块以外，用途完全不同，很少有能混用两种算法的情况。

DFS 最显著的特征在于其 递归调用自身 。同时与 BFS 类似，DFS 会对其访问过的点打上访问标记，在遍历图时跳过已打过标记的点，以确保 每个点仅访问一次 。符合以上两条规则的函数，便是广义上的 DFS。


```
dfs(v) // v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。
{
	在 v 上打访问标记
	for u in v 的相邻节点
	{
		if u 没有打过访问标记
		{
			dfs(u)
		}
	}
}
void dfs(int u)
{
	vis[u] = 1;
	for (int i = head[u]; i; i = e[i].next)
	{
		if (!vis[e[i].to])
		{
			dfs(v);
		}
	}
}
```
但是从个人的见解上看，DFS适用于路径的查询一些。
[例题-P1535 [USACO08MAR]Cow Travelling S](https://www.luogu.com.cn/problem/P1535)

说回来就是一个类似于主板的东西，我提供了扩展的范围，而你作为一个算法（电脑），至少得有CPU（ans++），内存（循环结束条件），磁盘（四方搜索），OS（按照题目进行相关修改）。别的，看看你的OS可以适配多少软件吧



