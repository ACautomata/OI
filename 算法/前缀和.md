只是记录一下二维的前缀和

普遍的利用方法都是**容斥**。

比如这样的一个矩阵：
```Python
1 2 4 3
5 1 2 4
6 3 5 9
```
前缀和拿来求各种各样的变体的问题，比如：[最大正方形](https://www.luogu.com.cn/problem/P1387)

先做一下处理：
```Python
1  3  7  10
6  9  15 22
12 18 29 45
```
即：`sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]`

比如这道题就可以直接去枚举以`i,j`所构成的长方形是不是`l*l`（因为只有`0`和`1`）
```C++
#include <algorithm>
#include <iostream>
using namespace std;
int a[103][103];
int b[103][103];  // 前缀和数组，相当于上文的 sum[]
int main() {
  int n, m;
  cin >> n >> m;

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> a[i][j];
      b[i][j] =
          b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1] + a[i][j];  
    }
  }

  int ans = 1;

  int l = 2;
  while (l <= min(n, m)) {
    for (int i = l; i <= n; i++) {
      for (int j = l; j <= m; j++) {
        if (b[i][j] - b[i - l][j] - b[i][j - l] + b[i - l][j - l] == l * l) 
          ans = max(ans, l);
    }
    l++;
  }

  cout << ans << endl;
  return 0;
}
```
# 差分
差分是一种和前缀和相对的策略，可以当做是求和的逆运算。

大概的指令就是:
`b[1]=a[1],b[i]=a[i]-a[i-1](a>1)`

它可以维护多次对序列的一个**区间**加上一个数，并在最后询问某一位的数或是多次询问某一位的数。注意修改操作一定要在查询操作之前。(如果你对分块是什么十分的好奇吧)
当然也可以求出原本的序列

比如一个简单的序列：
```python
a[i] 1  5  9  8  4  3
b[i] 1  4  4 -1 -4 -1
```
当然的，第一个数字应当与原数保持统一（相当于存在`a[0]=0`）

## 树上·边差分

树上差分的常见操作是给出你`a,b,k`，要求将`a`到`b`的最短路径上的所有点全部加上`k`。然后再进行`n`次操作之后，询问某一个点`p`的值.

当然的,常常需要借助**LCA**.

大致的公式即：

```C++
f[a]+=k;
f[b]+=k;
f[lca(a,b)]-=k;
f[fa[lca(a,b)]]-=k;
```
每一个点记录了自己的那一份`k`，但是当上回溯到`lca(a,b)`的时候，就出现了两份`k`，所以要减去一份，然后他的爸爸，跟这件事没有什么关系，也要删掉
PS：部分的(30%?)OI题目在考察相关内容的时候一般直接是访问的次数(`k`==1)

比如这个玩意儿[P3258 [JLOI2014]松鼠的新家](https://www.luogu.com.cn/problem/P3258)

这道题会把路径的终点算作起点接着用。剩下的就是跳跳权值，加加DFS

```
#include<iostream>//bis/stdc++.h
using namespace std;
struct node
{
	int u,v,nxt;
} edge[300001*2];
int deep[300001],ch[300001],head[300001],a[300001],f[300001][30],n,num=1;
int read()
{
	int x=0,w=1;
	char ch=0;
	while (ch<'0'||ch>'9')    
	{
		if (ch=='-') w=-1;     
		ch=getchar();             
	}
	while (ch>='0'&&ch<='9')   
	{
		x=x*10+(ch-'0');  
		ch=getchar(); 
	}
	return x*w;
}
inline void write(int x)
{
	static int sta[35];
	int top=0;
	do
		sta[top++]=x%10,x/=10;
	while (x);
	while (top) putchar(sta[--top]+48);
}
void add_edge(int x,int y)  
{
	edge[num].u=x;
	edge[num].v=y;
	edge[num].nxt=head[x];
	head[x]=num;
	num++;
}
void build(int r)   
{
	for(int i=head[r]; i!=-1; i=edge[i].nxt)
	{
		int xx=edge[i].v;
		if(deep[xx]==0)   
		{
			deep[xx]=deep[r]+1;
			f[xx][0]=r;
			build(xx);
		}
	}
}
int lca(int x,int y)
{
	if(deep[x]<deep[y]) 
		swap(x,y);
	for(int i=29; i>=0; i--)
		if(deep[f[x][i]]>=deep[y])
			x=f[x][i];
	if(x==y) 
		return x;
	for(int i=29; i>=0; i--)
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	return f[x][0];
}
void dfs(int r)
{
	for(int i=head[r]; i!=-1; i=edge[i].nxt)
	{
		int xx=edge[i].v;
		if(xx==f[r][0]) 
			continue;
		dfs(xx);
		ch[r]+=ch[xx];
	}
}
int main()
{
	n=read();
	for(int i=1; i<=n; i++)
	{
		a[i]=read();
		head[i]=-1;
	}
	int xx,yy;
	for(int i=1; i<=n-1; i++)
	{
		xx=read();
		yy=read();
		add_edge(xx,yy);
		add_edge(yy,xx);
	}
	deep[1]=1;
	build(1);
	for(int i=1; i<=29; i++)
		for(int j=1; j<=n; j++)
			f[j][i]=f[f[j][i-1]][i-1];
	for(int i=1; i<=n-1; i++)
	{
		xx=a[i];
		yy=a[i+1];
		ch[xx]++;
		ch[yy]++;
		ch[lca(xx,yy)]--;
		ch[f[lca(xx,yy)][0]]--;
	}
	dfs(1);
	for(int i=2; i<=n; i++)
		ch[a[i]]--;
	for(int i=1; i<=n; i++)
		write(ch[i]),printf("\n");
	return 0;
}
```

