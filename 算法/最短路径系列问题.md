# 最短路径算法

## 前置芝士

<strong>简单的建图</strong>

<pre><code class="line-numbers">int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    while(m--)
    {
        int x,y,w;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        g[x][y]=w;
    }
    return 0;
}


</code></pre>

<strong>链式前向星</strong>

<pre><code class="line-numbers">struct edge
{
    int v,w,nxt;
} e[1001];
int head[1001],n,m;
inline void add(int a,int b,int c)
{
    e[++num].nxt=head[a]; //h[a]是a的上家
    head[a]=num; //更新上家
    e[num].v=b; //这是边的终点
    e[num].w=c; //权值
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    while(m--)
    {
        int x,y,w;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        add(x,y,w);
//add(y,x,w);
    }
    return 0;
}
</code></pre>

<h1>Floyd</h1>

唯一的多源最短路算法（尽管它非常慢），这也就意味着它可以计算任意两点之间的最短路径。当然一个本质上是DP的玩意儿，也快不到哪儿去。**[不能处理负环]**
前方过于暴力请坐稳扶好，收起小桌板，打开遮光板，调直座椅靠背，洗手间暂停使用。
用邻接矩阵存最短路（dis[i][j] 表示i 到 j 的最短距离）开一个三重循环外层枚举中间点，中间枚举起点，内层枚举终点，当三个点互不相同时进行松弛操作，如果经过中间点之后的路程和比原路程短，就更新距离，一轮过后，我们得到了一个新的矩阵，然后我们把中间点换成下一个点，再次松弛，的到一个新的矩阵，执行 $n$ 次之后，第 $n$ 个矩阵就是我们的答案啦
由于有三重循环，每层都是 $n$ 轮，时间复杂度为 $O(n^3)$，虽然在稠密图中优势明显，但是对于稀疏图则占不到一点便宜，是一个虽然不是暴力但是比暴力还暴力的算法，依然是谨慎食用，以免超时，数据范围在 $n≤280$ 还是比较保险的
说白了，长得有点像二分的玩意儿。我们把这么一个长长的序列放上三个点，一个放在起点，一个放在中点，中间再丢一个，当然，你也不知道中间的丢在那儿更短。所以，你被迫的把每一个点都丢了一遍。
然后嘛，就是DP的转移方式了，既然有了中间的k点，那么到底是 $i->k->j短还是i->j$ 更快呢。于是$f[i][j]=min(f[i][j],f[i][k]+f[k][j]);$
PS:根据某大佬的说法，自己手写min的速度更快。

<pre><code class="line-numbers">//add(dis[]) and memset(dis,0x3f3f3f)
for(int k=1;k&lt;=n;++k)    //Mid
    for(int i=1;i&lt;=n;++i)    //start
        if(i!=k)    //don't find i==k
            for(int j=1;j&lt;=n;++j)    //end
                if(i!=j &amp;&amp; j!=k)    //don't find i==j==k
                    dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);    //DP
</code></pre>

<h1>Djikstra</h1>

最短路的主流算法，不能处理负边权
<img src="https://dss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2694089680,1353136258&amp;fm=179&amp;app=42&amp;f=JPEG?w=121&amp;h=140&amp;s=25941BD12E0B124D52809037030080E3" alt="dijkstra" />
先来搞一个图。
假设起点为a，问a到任意一点的最短路径

<pre><code class="line-numbers">a b 2
a d 6
a f 9
b c 30
b d 1
c h 5
d e 2
e g 7
e c 8
f e 3
f g 24
g h 21
只有单向！
</code></pre>

Dijkstra 的思路是维护一个集合，集合内的点是已经确定最短路的点，可以视为一个大整体，每次操作找出与集合相邻且距离起点最近的点加入集合中，并确定它的最短路为它的上家的最短路+该边权值，存在dis[]中。
有dis[] 现在将a 加入集合，$s={a}，有dis={0,∞,∞,∞,∞,∞,∞,∞}，$然后再加入$b，s={a,b}, dis={0,2,∞,∞,∞,∞,∞,∞}，$然后再遍历$b$节点下的最近点（没错，$b$也是这么选出来的），加入$d。s={a,b,d}, dis={0,2,∞,3,∞,∞,∞,∞} &lt;3=2+1>。$再搜索$d，$走向$e。s={a,b,d,e}, dis={0,2,∞,3,5,∞,∞,∞}。在走向g，s={a,b,d,e,g}, dis={0,2,∞,3,5,∞,12,∞}$

<pre><code class="line-numbers">void dijkstra()
{
    memset(dis,127/3,sizeof(dis));    
    v[1]=1;
    dis[1]=0;
    for(int i=1;i&lt;=n;++i)
    {
        int k=0;
        for(int j=1;j&lt;=n;++j)
            if(!v[j]&amp;&amp;(k==0||dis[j]&lt;dis[k]))
                k=j;
        v[k]=1;
        for(int j=1;j&lt;=n;++j)
            if(!v[j] &amp;&amp; dis[k]+a[k][j]&lt;dis[j])
                dis[j]=dis[k]+a[k][j];
    }
}
</code></pre>

<h2>Dj的优化</h2>

众所周知的，dijkstra的时间复杂度是O(n²)，用这种算法无异于自爆。那就只好用优先队列priority_queue了。这个玩意儿可以自动排序（不需要慢慢去执行松弛和查找了），就好比你把一堆各异的东西丢进水里，浮出来的那个就是最小的啊。然鹅，不能在线修改。。。丢进去了就是在水里了，至于水里的哪里，不知道。
<img src="https://i.loli.net/2018/08/11/5b6eca17075cd.jpg" alt="o(╥﹏╥)o" />

<pre><code class="line-numbers">inline void dijkstra()   //可以不带参数，也可以把起点带进来
{
    priority_queue q;//优先队列大法吼
    q.push(element(1,0));//把起点压进去
    while(!q.empty())   //不空就说明还有点没搜完
    {
        element k=q.top();//取出队首
        q.pop();
        if(vis[k.node])//如果已经在集合中（被搜到过）
            continue;//扔掉
        vis[k.node]=1;//标记
        dis[k.node]=k.value;//存下最短路（由于优先队列的排序已经相当于完成了松弛，所以这就是答案）
        for(vector::iterator it=v[k.node].begin(); it!=v[k.node].end(); ++it) //用指针遍历邻接表
            q.push(element(it-&gt;node,it-&gt;weight+k.value));//松弛
    }
}
</code></pre>

这样一来，O(e+n)logn。就可以处理稀疏图了。

<h1>Bellman-Ford 负权的朋友</h1>

Bellman-Ford常常会被用于判断甚至计算负环的情况。主旨是迭代的思想，枚举距离出发点的边，每次去松弛某个点到出发点的距离。但是Bellman算法以盲目且过量的枚举使得这样的算法十分的低效。任意的n个点都需要枚举n-1次。
如何证明它的**呢。
首先，我们从A边开始，但是A边的两边都是∞，没有可以更新的，B边同理。接着C边。由于dis<a href="https://dss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2694089680,1353136258&amp;fm=179&amp;app=42&amp;f=JPEG?w=121&amp;h=140&amp;s=25941BD12E0B124D52809037030080E3">1</a>=0，所以0+2&lt;∞，所以dis<a href="https://i.loli.net/2018/08/11/5b6eca17075cd.jpg">2</a>=2，然后D边得到dis[3]=1，枚举E边，dis[4]=3。恭喜你，第一次的循环做完了。然后进行第二轮的搜索…与上同理。反复的更新节点的最短路。 当然，这样的算法通常易于理解（或者写），Bellman算法 的循环只有两次if，分别判断A->B 以及 B->A 的，看看能不能更新当前节点的最短路。
判断负环的情况：

<pre><code class="line-numbers">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
#define MAX 0x3f3f3f3f
#define N 100010
long long n,m,s,t;
struct edge
{
    long long x,y;
    long long cost;
};
edge v[5*N];
long long dis[N];
bool Bellman_Ford()
{
    for(int i=1;i&lt;=n;++i)
        dis[i]=(i==s? 0:MAX);
    for(int i=1;i&lt;n;++i)
        for(int j=1;j&lt;=m;++j)
        {
            if(dis[v[j].y]&gt;dis[v[j].x]+v[j].cost)//松弛有向图
                dis[v[j].y]=dis[v[j].x]+v[j].cost;
        }
    bool flag=1;//标记有无负环
    for(int i=1;i&lt;=m;++i)
        if(dis[v[i].y]&gt;dis[v[i].x]+v[i].cost)//松弛是否成功
        {
            flag=0;//成功则有负环
            break;
        }
    return flag;
}
int main()
{
    scanf("%lld%lld%lld%lld",&amp;n,&amp;m,&amp;s,&amp;t);
    for(int i=1;i&lt;=m;++i)
        scanf("%lld%lld%lld",&amp;v[i].x,&amp;v[i].y,&amp;v[i].cost);
    if(Bellman_Ford())//无
        printf("%lld\n",dis[t]);
    else
        printf("no\n");
    return 0;
}
</code></pre>

外层的循环最多n-1次，因为有n个节点，内层循环依情况而定。O(nm)，这也就以为着10^6就挂了。

<h1>SPFA</h1>

先把代码放出来。

<pre><code class="line-numbers">int dis[MAXN];//dis[i]=源点s-&gt;i最短路径
bool vis[MAXN];//vis[i]表示i是否在队列
void spfa(int s)
{
    for(int i=1; i&lt;=MAXN; i++) //初始化 { dis[i]=INF; vis[i]=true; } dis[s]=0;//源点到自身距离为0 queue q;//使用C++自带队列
        q.push(s);//源点入队
    vis[s]=false;
    while(!q.empty()) //若队列不为空
    {
        int u=q.front();//取出队首元素弹出
        q.pop();
        vis[u]=true;
        for(int i=head[u]; ~i; i=ed[i].next) //遍历
        {
            int v=ed[i].to;
            if(dis[u]+ed[i].w&lt;dis[v]) //如果不满足三角形不等式
            {
                dis[v]=dis[u]+ed[i].w;//更新答案
                if(vis[v]) //如果终点不在队列
                {
                    q.push(v);//入队
                    vis[v]=false;
                }
            }
        }
    }
}
</code></pre>

<h2>SPFA判断负环</h2>

虽然吧，我还是认为Floyd挺香的。不过还是可以康康DFS的SPFA。
例如判负时，我们就跑最短(改什么自己思考)。如果跑到一点时递归栈内已经有该点了，那么就是一个负环。思路其实和bfs差不多吧，不过dfs有它自己的特点。存在负环时，最短路会一直在上面绕，我们猜测一条路径经过两次同一点即可判为存在负环。如果最短路经过两次同一点，那么肯定存在一个环。假设第二次经过同一点就往别的地方走，可以得到新路比原路(即环)路径短，这与第一次经过该点时产生矛盾(因为第一次经过该点然后走了一个环是因为该环最短)，所以肯定还是走那个环，这张图存在负环。证毕。

<pre><code class="line-numbers">void spfa(int a)
{
    instack[a]=true;//节点入栈
    for(int i=head[a]; ~i; i=e[i].next) //遍历出边
        if(dis[a]+e[i].w&lt;dis[e[i].to]) //如果满足条件
        {
            dis[e[i].to]=dis[a]+e[i].w;//更新答案
            if(!instack[e[i].to]) //如果终点不在栈内
                spfa(e[i].to);//深搜
            else //否则
                return ;
        }
    instack[a]=false;//将当前结点退栈
}

</code></pre>
