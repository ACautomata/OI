>树状数组是一种用于维护前缀信息的的数据结构，其实现十分简洁优美。（当然简单易懂） 

<!--more-->

## 前置芝士
`lowbit` 这个函数是表示一个数n所表达的是二进制最低位**1**所对的值（意思就是二进制下最低位的1） 比如(6)10的二进制是(110)2，所以` lowbit(6) = 2 `，主要的写法就是

  ```C++
int lowbit(int x){
    return x & -x; }
  ```

​	当然还有另一种写法， `return x&(x^(x-1))`相较之下，第一种方法利用了**负整数的补码特性**，非常的巧妙，而第二种算法用另外一种方式计算出了最低位，其思想跟补码的也很相似。当然还是推荐第一种，不仅巧妙而且好记。
 在后面的计算中，我们偶尔会遇到将`lowibit()+1`的操作，因为会遇到计算0s的情况然而`lowbit(0) = 0`没有达到计算`lowbit`的效果。

### 关于树状数组的原理

直接举一个例子来证明吧，你眼前的是一行数字：（`leng = 8`）

```
1 2 3 4 5 6 7 8
```

我们把它处理一下，可以得到一个两个节点整合为一个节点的二叉树：

```
            ○
           / \
          /   \
         /     \
        /       \
       /         \
      ○           ○
     / \         / \
    /   \       /   \
   ○     ○     ○     ○
  / \   / \   / \   / \
 1  2  3   4 5   6 7   8
```

可是这个样子有点难以记录啊，比如最上面的点，我们只能表示为O(4.5,12) Σ(っ°Д°;)っ  ，那。。。换个样子:![节点就不表示了](https://s1.ax1x.com/2020/06/27/N68fFf.png)
树状数组为了尽可能的减少memory的占用，因此删除了所有的不必要的点，将节点的数组减少到了和数字的数量相同（不信你数），同时也保障了每一个数字都可以引向（追溯）到ROOT节点（最高点），比如位置4就代表了`[1 ,4]`，位置6就代表了`[5,6]`，位置8就代表了`[1,8]`，这么安排下来，得到的数组有一个特点：对于处于数组位置 i 的结点，其代表的信息区间为 `[i - lowbit(i) + 1, i]`。比如说对于位置 6，其二进制表示为 110，它所代表的也就是 `[101, 110]` 这两个元素的**信息整合**；对于位置8，其二进制表示为 1000，它所代表的也就是 `[0001, 1000]` 这八个元素的**信息整合**。

## 树状数组的基本操作 - 甲

### 单点修改

脑子也不用动吧，当我修改第`i`个点时，我要同时修改其可以引向的所有节点的前缀和，这就好比我刚刚在上面的代码版的树状数组图的时候，打错了任意一个`\`的位置，我都需要从新修改一遍A→B之间的所有`/`，(*^▽^*)  ，即**修改并向上修改（维护？覆盖）**

```c++
inline void sin_add(int x,int y)
{
    for(;x<=n;x+=x&-x)
      c[x]+=y;
}
```

![还是留一张图吧...随便举得例子](https://s1.ax1x.com/2020/06/27/N6JDrd.png)

### 区间查询

查询树状数组时，我们是要查询区间 `[1, i] `的整合信息。查询方法很简单，反复令 `i = i - lowbit(i)`，整合路径上的信息，直到 `i == 0` 为止。为什么可以这么搞？我给 `f(i) = i - lowbit(i) `画个图就很显然了：![借鉴自链接：https://www.zhihu.com/question/54404092/answer/785844116    有删减，感谢大佬 ](https://pic3.zhimg.com/80/v2-b3f7bccdbbe043154137e123b7e2bfbb_720w.jpg)
图中每一个结点 i 上的红色箭头指向它的 `i - lowbit(i)` 的结果。可以看到，一个结点 i 的位置减去 `lowbit(i)` 之后，其实就代表着向左离开它所表示的信息区间。比如说如果 i=7，那么由之前所说的我们知道 i 的信息区间长度为 `lowbit(7)=1`， 那么我们记录下` [7, 7]` 区间的信息，开始往回走。往回走就是减去当前信息区间的长度，到达刚才没有覆盖的区间，也就刚好是减去 `lowbit(7)=1`得到 `i=6`；然后 i 的信息区间长度为 `lowbit(6)=2`， 那么我们用` [5, 6]` 区间的信息更新手上的信息，继续往回走，也就是减去 `lowbit(6)=2`得到 `i=4`；然后 `i=4`，区间长度为`lowbit(4)=4`，再用` [1, 4] `的信息来更新手上的信息，继续往前走，减去 `lowbit(4)=4`得到 `i=0`；此时说明我们已经考虑到了整个的查询区间，不需要继续了

```c++
inline int pl_ask(int x)
{
    int ans=0;
    for(;x;x-=x&-x)
      ans+=c[x];
    return ans;
}
```

（忘记补代码了）

### 区间修改

**这个相对较难。原因：算法书上一般不讲。**
刚刚的那个叫做单点修改，这个嘛。。。很明显的，对一个区间内的值进行+/-数值
这个时候我们要运用到**差分**的思想。
比如有一个数组a`[1,3,4,5,3]`
它所对应的差分数组就是`b = [1,2,1,1,-2]`,即`b[i] = a[i] - a[i - 1] `；
时间复杂度：` O(n) `到 `O(logn)`，线性差分是1~n线性的。而运用到树状数组中，就是以上图的方式记录差分；也就是预处理一部分和，查找时降低时间复杂度。同样地，分块的方式基本相似。

```c++
inline void sin_add(int pos,int val)
{
    for(;pos<=n;pos+=pos&-pos)
      c[pos]+=val;
}
inline void pl_add(int l,int r,int x)
{
    sin_add(l,x);
    sin_add(r+1,-x);//至于为什么这里是加的-x吗，x是一个负数<0.
}
```

根据d的定义，对`[l,r]`区间加上x，那么`a[l]`和`a[l-1]`的差增加了x，`a[r+1]`与`a[r]`的差减少了x，所以就对差分数组的前缀和进行修改.

### 单点查询

思路简单，代码暴力

>转为二进制，并向下（覆盖）查找 

```c++
inline int sin_ask(int pos)
{
    int ans=0;
    for(;x;x-=x&-x)
      ans+=c[x];
    return ans;
}
```

不知道你有没有发现[单点查询] 和 [区间查询] 的代码是一样的，因为他们从本质上讲都是区间求和（只不过单点求和比较的特殊，求的是差分的和等价于单点）。

## 树状数组的基本操作 - 乙

在这里 我们将会提到另一种有关单点求和以及区间修改的算法（顺带提一下区间求和和单点增加

**区间求和以及单点增加**

```c++
int ask(int x)//区间求和
{
	int ans = 0;
	for (; x; x -= x & -x)
		ans += c[x]//区间相加
	return ans;
}
void add(int x, int y)//单点增加
{
    for(; x <= N; x += x & -x)
        	c[x] += y;
}
```

**单点求和以及区间修改**

对于输入，首先输入长度为N的序列A，然后输入Q行操作 

第一类，形如「C l r d」，表示把数列中第l ~ r的数都加d 

第二类，形如「Q x」，表示询问数列中第x个数的值 

我们可以新建一个数组`b[](copy a[])`用于记录前缀和的变化。即每一次「C l r d」的操作，都执行

```c++
b[l] += d;
b[r + 1] -= d;
```

对于每一次「Q x」的操作，执行

```c++
int ask(int x)//区间求和
{
	int num = 0;
	for (; x; x -= x & -x)
		ans += c[x]//区间相加
	return num;
}
ans = a[x] + ask(x);
```

**WHY?**



## 树状数组的初始化

**方法一**

直接建立里一个全部为0的`c[]`，接着对每一个数字`x`，执行`add(x)`操作，时间复杂度为`O(N log N)`，**通常采用这种方法就足够了**。

**方法二**

从小到大依次次考虑每个节点`x`，借助`lowbit()`运算扫描他的子节点并求和。这样一来，树形结构中的每一条边只会被遍历一次。`O(N)`.



 [等等，我还没做...(*￣０￣)ノ]()  

### 
